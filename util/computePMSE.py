# this script evaluates inference performed on data generated by simulations.
# there are many assumptions made about the format of the data etc so the
# script must be used exactly as expected.
# - data files are expected to be in 'examples/tipping/data/generatedData/<N>'
#   where N is the number of rounds (and should be passed as argument to
#   this script) and are expected to be called 'simulation<M>.csv' for M
#   ranging from 0 to some number K-1 where K must be passed as arg to this
#   script.
# - results of inference are expected to be in a file
#   'examples/tipping/results/inferFromGenerated<N>rounds.txt' where N
#   is as above.

# This script first reads all the data files to retrieve the actual
# parameters used for simulations (PHASE 1)

# Then, the script reads the results containing posteriors learned from
# each data file and saves the posteriors in a list (very simple
# representation, takes advantage of the fact that distributions are
# discrete) (PHASE 2)

# Finally, each posterior is evaluated by computing PMSE (separately for
# goal coeffs, tipping norm and gasp score). Then, the PMSEs are
# averaged, both as mean and median. (PHASE 3)

import sys
assert len(sys.argv) == 3

rounds = int(sys.argv[1])
files_no = int(sys.argv[2])


# PHASE 1
params = []

for i in range(files_no):
    filename = "examples/tipping/data/generated/" + str(rounds) + "/simulation" + str(i) + ".csv"
    with open(filename,"r") as f:
        content = f.readlines()
        # need to get goal coeffs (line 1), tipping norm + gasp score (line 4)
        firstLine = content[0]
        a = firstLine.find("[")
        b = firstLine.find(",")
        moneyCoeff = float(firstLine[a+1:b])
        tippingNorm = int(content[3].split(";")[0])
        gaspScore = int(content[3].split(";")[2])
        params.append([moneyCoeff, tippingNorm, gaspScore])
# now we should have all the params in a list

# PHASE 2
posterior = []
with open("examples/tipping/results/inferFromGenerated5rounds.txt", "r") as f:
    content = f.readlines()
    lineNo = 3
    simNo = 0
    while lineNo < len(content):
        # process next simulation
        while not content[lineNo].startswith("abi"):
            lineNo += 1
        lineNo += 1
        # now we are at goal coeffs
        goalCoeffProbs = []
        while not content[lineNo].startswith("tipping"):
            line = content[lineNo]
            indexOfFirstComma = line.find(",")
            indexOfSecondComma = line.rfind(",")
            indexOfLastChar = line.find(")")
            moneyCoeff = float(line[2:indexOfFirstComma])
            prob = float(line[indexOfSecondComma+1:indexOfLastChar])
            goalCoeffProbs.append([moneyCoeff, 1/6])
            # goalCoeffProbs.append([moneyCoeff, prob])
            lineNo += 1
        lineNo += 1
        # now we are at tipping norm
        normProbs = []
        while not content[lineNo].startswith("gasp"):
            line = content[lineNo]
            pair = line.rstrip()[1:-1].split(",")
            norm = int(pair[0])
            prob = float(pair[1])
            normProbs.append([norm,1/5])
            # normProbs.append([norm,prob])
            lineNo += 1
        lineNo += 1
        # now we are at gasp score
        gaspProbs = []
        while not content[lineNo].startswith("undefined"):
            line = content[lineNo]
            pair = line.rstrip()[1:-1].split(",")
            gasp = int(pair[0])
            prob = float(pair[1])
            # gaspProbs.append([gasp, prob])
            gaspProbs.append([gasp, 1/4])
            lineNo += 1
        lineNo += 1
        simNo += 1
        posterior.append([goalCoeffProbs, normProbs, gaspProbs])

if not len(params) == len(posterior):
    print("Something went wrong, posterior array has different dimensions" +
    " than params array")
    exit(1)

# PHASE 3

pmses = []
tops = []

for (values, predictions) in zip(params, posterior):
    l = []
    t = []
    for (value, prediction) in zip(values, predictions):
        topPrediction = prediction[0][0]
        t.append(int(abs(topPrediction - value) <= 0.1))
        pmse = 0
        for pair in prediction:
            prob = pair[1]
            predVal = pair[0]
            pmse += prob * pow(value - predVal, 2)
        l.append(pmse)
    pmses.append(l)
    tops.append(t)


# pmses holds all the... pmses, as a list of 3 element lists
# tops has the same format but holds 1 or 0

def sumElementWise(arrayOfArrays):
    result = [0,0,0]
    for array in arrayOfArrays:
        result = [sum(x) for x in zip(result, array)]
    return result

# pmsesSum = [0,0,0]
# for pmse in pmses:
#     pmsesSum = [sum(x) for x in zip(pmsesSum, pmse)]

pmsesSum = sumElementWise(pmses)
n = len(pmses)
averagePmses = [x / n for x in pmsesSum]
print("mean averages (respectively for goal coeffs, tipping norm and gasp score):")
print(averagePmses)

# compute median pmses
l = [[],[],[]]
for pmse in pmses:
    for i in range(len(pmse)):
        l[i].append(pmse[i])

from statistics import median

medians = list(map(median, l))

print("medians (respectively for goal coeffs, tipping norm and gasp score):")
print(medians)



topsSums = sumElementWise(tops)
# print("binary:")
# print(topsSums)

